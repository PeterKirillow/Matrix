using System;
using System.Configuration;

namespace Matrix
{
    public class M3
    {
        /*
         * нахождение обратной матрицы    
         * http://www.mathprofi.ru/kak_naiti_obratnuyu_matricu.html
         */
        public M3(string sm)
        {
            _matrix A = new _matrix(ConfigurationManager.AppSettings.Get($"M.{sm}"));

            int rows = A.rows;
            int columns = A.columns;

            if (rows != columns)
            {
                Console.WriteLine("Понятие обратной матрицы существует только для квадратных матриц");
            }
            else
            {
                // находим определитель матрицы
                double d = determinant(A);
                Console.WriteLine("A:");
                A.print_matrix();
                Console.WriteLine($"Определитель матрицы:\n{d}");
                if (d == 0)
                {
                    Console.WriteLine("Определитель равен нулю. Обратной матрицы не существует.");
                }
                else
                {
                    // будем находить обратную матрицу с помощью алгебраических дополнений
                    // 1. находим матрицу миноров
                    _matrix A_minor = minor(A);
                    Console.WriteLine($"Минорная матрица:");
                    A_minor.print_matrix();

                    // 2. находим матрицу алгебраических дополнений (меняем знаки)
                    // правила по сути такие же, как и в случае нахождения определителя, т.е. + чередуется с -. минус - означает смену знака (умнодаем на -1)
                    /* для 2 на 2
                    *  + -
                    *  - +
                    */
                    /* для 3 на 3
                    * + - +
                    * - + -
                    * + - +
                    */
                    // и так далее
                    int z;
                    for (int r = 0; r < A_minor.rows; r++)
                    {
                        for (int c = 0; c < A_minor.columns; c++)
                        {
                            // для четной строки и для нечетной строки определение мультипликатора будет разным
                            if ( (r+1) % 2 == 0 )
                            {
                                // для четной строки
                                // четная колонка - не меняем знак, нечетная колонка - меняем
                                z = (c+1) % 2 == 0 ? 1 : -1;
                            } else
                            {
                                // для нечетной строки
                                // четная колонка - меняем знак, нечетная колонка - не меняем
                                z = (c+1) % 2 == 0 ? -1 : 1;
                            }
                            A_minor.M[r, c] = A_minor.M[r, c] * z;
                        }
                    }
                    Console.WriteLine($"Матрица алгебраических дополнений:");
                    A_minor.print_matrix();

                    // 3. транспонируем матрицу алгебраических дополнений
                    A_minor.transposition();
                    Console.WriteLine($"Транспонировання матрица:");
                    A_minor.print_matrix();

                    // 4. итогом является умножение транспонированной матрицы на 1/определитель
                    Console.WriteLine($"Обратная матрица:");
                    Console.WriteLine($"1/{d} *\n(");
                    A_minor.print_matrix();
                    Console.WriteLine(")");
                }

            }

        }

        // -----------------------------------------------------------------------------------------------------------------------------
        // нахождение определителя по статье - http://www.mathprofi.ru/kak_vychislit_opredelitel.html
        // базовая функция для определителя 2-го уровня. К ней будем прибегать, вычисляя в рекурсии определите миноров в массивах урояня больше 2.
        // проверку на ошибки НЕ делаем
        double determinant_2(_matrix m)
        {
            double d = 0;
            // проверка 2 на 2
            if (m.columns == 2 && m.rows == 2)
            {
                d = (m.M[0, 0] * m.M[1, 1]) - (m.M[1, 0] * m.M[0, 1]);
            }
            else
            {
                d = 0;
            }
            return d;
        }

        // -----------------------------------------------------------------------------------------------------------------------------
        // нахождение определителя в рекурсивном цикле для матрицы любого порядка
        // проверку на ошибки НЕ делаем
        // определитель решаем, раскрыв его по 0 (1-й) строке.
        double determinant(_matrix m)
        {
            double d = 0;
            int z;
            if (m.columns == m.rows)
            {
                if (m.columns == 2)
                {
                    // если это матрица 2 на 2, то получаем определитель из базовой функции
                    d = determinant_2(m);
                }
                else
                {
                    // пороход по колонкам первой строки матрицы
                    for (int c = 0; c < m.columns; c++)
                    {
                        // первая строка у нас по знакам будет: + - + - + ... 
                        // знаки чередуются, поэтому 1 колонка - это нечетное число (знак +), 2я- четное (знак -) и так далее
                        z = (c + 1) % 2 == 0 ? -1 : 1;

                        // собственно само число из 0й строки и c-ой колонки. сразу помножим на знак.
                        double v = z * m.M[0, c];

                        // теперь создаем новый массив c-1 на r-1
                        // т.е. создаем класс и удаляем 0 строку и c-ю колонку
                        _matrix T = new _matrix(m.M);
                        T.delete_row(0);
                        T.delete_column(c);

                        // вызывем себя, пока не дойдем до базовой функции 2-го порядка
                        // не забываем результаты сумировать с учетом знака
                        double dminor = determinant(T);
                        d = d + (dminor * v);
                    }
                }
            }
            else
            {
                d = 0;
            }

            return d;
        }

        // -----------------------------------------------------------------------------------------------------------------------------
        _matrix minor(_matrix m)
        {
            _matrix rm = new _matrix(new double[m.rows,m.columns]);
            if (m.columns == 2 && m.rows == 2)
            {
                // матрица миноров 2 на 2. Отличается от нахождения миноров для матриц большего порядка
                rm.M[0, 0] = m.M[1, 1];
                rm.M[0, 1] = m.M[1, 0];
                rm.M[1, 0] = m.M[0, 1];
                rm.M[1, 1] = m.M[0, 0];
            } else
            {
                // для матриц порядка больше 2х упражнение сводится к нахождению определителей миноров и размещении их на своих местах в матрице
                rm = m;
            }
            return rm;
        }

    }
}
